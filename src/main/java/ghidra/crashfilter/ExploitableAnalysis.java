package ghidra.crashfilter;

import java.util.*;

import ghidra.app.util.PseudoDisassembler;
import ghidra.app.util.PseudoInstruction;
import ghidra.crashfilter.BinNavi.mono.InstructionGraphNode;
import ghidra.crashfilter.dataflow.DefUseChain;
import ghidra.crashfilter.helper.GhidraConsolePrint;
import ghidra.crashfilter.helper.PcodeResolver;
import ghidra.program.model.address.Address;
import ghidra.program.model.lang.InsufficientBytesException;
import ghidra.program.model.lang.UnknownContextException;
import ghidra.program.model.lang.UnknownInstructionException;
import ghidra.program.model.listing.Function;
import ghidra.program.model.pcode.PcodeOp;
import ghidra.program.model.pcode.Varnode;

//import DefUseChain;

public class ExploitableAnalysis {
	private List<DefUseChain.DefUseGraph> duGraphs;
	private Function func;
	private Map<DefUseChain.DefUseNode, List<DefUseChain.DefUseNode>> exploitReilPaths = new HashMap<DefUseChain.DefUseNode, List<DefUseChain.DefUseNode>>();

	private Map<PseudoInstruction, List<PseudoInstruction>> exploitArmPaths = new HashMap<PseudoInstruction, List<PseudoInstruction>>();

	private Address crashAddr;

	private int e_count = 0;
	private int pe_count = 0;

	private int total_e_count = 0;

	private Dangerousness dangerousness;

	public void setDangerousness(Dangerousness dangerousness) {
		this.dangerousness = dangerousness;
	}

	public Dangerousness getDangerousness() {
		return dangerousness;
	}

	public int getTotal_e_count() {
		return total_e_count;
	}

	public int getTotal_pe_count() {
		return total_pe_count;
	}

	int total_pe_count = 0;

	public ExploitableAnalysis(List<DefUseChain.DefUseGraph> duGraphs, Function func, Address crashAddr) {
		this.duGraphs = duGraphs;
		this.func = func;
		this.crashAddr = crashAddr;
	}

	public Map<PseudoInstruction, List<PseudoInstruction>> getExploitArmPaths() {
		return exploitArmPaths;
	}

	public Map<DefUseChain.DefUseNode, List<DefUseChain.DefUseNode>> getExploitReilPaths() {
		return exploitReilPaths;
	}

	private PseudoInstruction toArmInstruction(DefUseChain.DefUseNode duNode) {
		PseudoDisassembler pdis = new PseudoDisassembler(func.getProgram());
		PseudoInstruction psi = null;
		try {
			psi = pdis.disassemble(duNode.getInst().getAddr());
		} catch (InsufficientBytesException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (UnknownInstructionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (UnknownContextException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return psi;

	}

	public void projectReilExploitToArmExploit() {
		for (DefUseChain.DefUseNode duNode : exploitReilPaths.keySet()) {

			PseudoInstruction exploitPoint = toArmInstruction(duNode);
			List<PseudoInstruction> armPath = new ArrayList<PseudoInstruction>();

			for (DefUseChain.DefUseNode node : exploitReilPaths.get(duNode)) {
				// LogConsole.log(node.getInst().toString()+"\n");
				PseudoInstruction armInst = toArmInstruction(node);
				if (!armPath.contains(armInst)) {
					armPath.add(armInst);
				}
			}

			// Filtering the duplicated Path
			// It is because we analyze every each REIL instruction that is translated from
			// one ARM instuction
			if (exploitArmPaths.isEmpty()) {
				exploitArmPaths.put(exploitPoint, armPath);
			} else {
				boolean isContain = false;
				for (PseudoInstruction inst : exploitArmPaths.keySet()) {
					if (exploitArmPaths.get(inst).containsAll(armPath)
							&& armPath.containsAll(exploitArmPaths.get(inst))) {
						isContain = true;
					}
				}
				if (!isContain) {
					exploitArmPaths.put(exploitPoint, armPath);
				}
			}
		}
	}

	public boolean isTaintSink() {
		return isExploitable();
	}

	public boolean isExploitable() {

		// Find exploitable points and paths
		searchExploitablePoint();
		projectReilExploitToArmExploit();
		if (exploitReilPaths.isEmpty()) {
			return false;
		}

		return true;
	}

	private boolean isDefUsedInAddressToBranch(InstructionGraphNode use, InstructionGraphNode def) {
		if (use.getPcode().getInput(0).isRegister()) {
			for (Varnode op : PcodeResolver.resolveReilInstructionDest(def)) {
				if (use.getPcode().getInput(0).equals(op)) {
					return true;
				}
			}
			return false;
		}
		return false;
	}

	private boolean isDefUsedInAddressToStore(InstructionGraphNode use, InstructionGraphNode def) {
		if (use.getPcode().getOutput().isRegister()) {
			for (Varnode op : PcodeResolver.resolveReilInstructionDest(def)) {
				if (use.getPcode().getOutput().equals(op)) {
					return true;
				}
			}
			return false;
		}
		return false;
	}

	private boolean isDefUsedInDataToStore(InstructionGraphNode use, InstructionGraphNode def) {
		if (use.getPcode().getInput(0).isRegister()) {
			for (Varnode op : PcodeResolver.resolveReilInstructionDest(def)) {
				if (use.getPcode().getOutput().equals(op)) {
					return true;
				}
			}
			return false;
		}
		return false;
	}

	// to check the parents
	// ---------------------------------------------------------------------
	private boolean isExploitableInstruction(DefUseChain.DefUseNode node) {

		PcodeOp inst = node.getInst().getPcode();

		if (inst.getOpcode() == PcodeOp.BRANCH || inst.getOpcode() == PcodeOp.BRANCHIND
				|| inst.getOpcode() == PcodeOp.CALL || inst.getOpcode() == PcodeOp.CALLIND
				|| inst.getOpcode() == PcodeOp.CALLOTHER || inst.getOpcode() == PcodeOp.RETURN) {
			for (DefUseChain.DefUseNode duNode : node.getParents()) {
				if (isDefUsedInAddressToBranch(node.getInst(), duNode.getInst())) {
					// LogConsole.log("E - jcc\n");
					e_count++;
					return true;
				}
			}
			return false;
		}

		else if (inst.getOpcode() == PcodeOp.STORE) {
			for (DefUseChain.DefUseNode duNode : node.getParents()) {

				if (isDefUsedInAddressToStore(node.getInst(), duNode.getInst())) {
					if (isDefUsedInDataToStore(node.getInst(), duNode.getInst())) {
						e_count++;
						return true; // Exploitable
					}
					pe_count++;
					return true; // Probably Exploitable
				} else if (isDefUsedInDataToStore(node.getInst(), duNode.getInst())) {
					pe_count++;
					return true;
				}
			}
			return false;
		}

		else
			return false;

	}

	private void searchExploitablePoint() {
		// All the graphs is analyzed at this function
		e_count = 0;
		pe_count = 0;
		for (DefUseChain.DefUseGraph duGraph : duGraphs) {
			Stack<DefUseChain.DefUseNode> stackDFS = new Stack<DefUseChain.DefUseNode>();
			Set<DefUseChain.DefUseNode> visitedNodes = new HashSet<DefUseChain.DefUseNode>();
			// We find all possible exploitable instruction in this function
			// We consider the possibility in detail after this process
			// Depth First Search Algorithm
			// System.out.println("search : "+duGraph.getNodes().get(0));
			searchExploitableDFS(stackDFS, visitedNodes, duGraph.getNodes().get(0));
		}

//		LogConsole.log("crashAddr  : " + crashAddr + "\n");
//		LogConsole.log("e  : " + e_count + "\n");
//		LogConsole.log("pe : " + pe_count + "\n");
//		LogConsole.log("total : " + (e_count + pe_count) + "\n");

		total_e_count += e_count;
		total_pe_count += pe_count;

		setFilteringResult(e_count, pe_count);
	}

	private void setFilteringResult(int e_count, int pe_count) {
		if (e_count > 0) {
			this.dangerousness = Dangerousness.E;
		} else if (pe_count > 0) {
			this.dangerousness = Dangerousness.PE;
		} else {
			this.dangerousness = Dangerousness.NE;
		}

	}

	private void searchExploitableDFS(Stack<DefUseChain.DefUseNode> stackDFS, Set<DefUseChain.DefUseNode> visitedNode,
			DefUseChain.DefUseNode duNode) {

		// current node processing
		visitedNode.add(duNode);
		stackDFS.push(duNode);
		if (isExploitableInstruction(duNode)) {
			List<DefUseChain.DefUseNode> exploitPath = new ArrayList<DefUseChain.DefUseNode>();
			exploitPath.addAll(stackDFS);
			exploitReilPaths.put(duNode, exploitPath);

		}

		// children iteration
		for (DefUseChain.DefUseNode node : duNode.getChildren()) {

			if (!visitedNode.contains(node)) {
				searchExploitableDFS(stackDFS, visitedNode, node);
			}
		}

		stackDFS.pop();
	}

}
